#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;#define INF 200000000;int graph[1000][1000];bool visited[1000][1000][9];int main(){  int a,b; cin >> a >> b;  for (int i=0;i<a;i++)    for (int j=0;j<b;j++)
      cin >> graph[i][j];  queue<pair<pair<pair<int,int>,pair<int,bool> >,pair<int,int> > > q;  q.push(make_pair(make_pair(make_pair(0,0),make_pair(0,0)),make_pair(0,0)));  visited[0][0][0] = true;  int x[4] = {0,1,0,-1};  int y[4] = {1,0,-1,0};int mini = INF;queue<pair<int,int> > direction;  while(!q.empty()){    int qf = q.front().first.first.first;    int qs = q.front().first.first.second;bool smell = q.front().first.second.second;    int df = q.front().second.first;    int ds = q.front().second.second;    int point = q.front().first.second.first;if (qf == a-1 && qs == b-1) {      mini = min(mini,point);      break;    }int gn = graph[qf][qs];    if(gn == 0){q.pop();}else if(gn == 1){      for (int i=0;i<4;i++){        if (qf+x[i]>=0 && qs+y[i]>=0 && qf+x[i]<a && qs+y[i]<b){if(smell){            if (!visited[qf+x[i]][qs+y[i]][i+5]){              q.push(make_pair(make_pair(make_pair(qf+x[i],qs+y[i]),make_pair(point+1,smell)),make_pair(x[i],y[i])));              visited[qf+x[i]][qs+y[i]][i+5] = true;            }}else if(!visited[qf+x[i]][qs+y[i]][i+1]){            q.push(make_pair(make_pair(make_pair(qf+x[i],qs+y[i]),make_pair(point+1,smell)),make_pair(x[i],y[i])));            visited[qf+x[i]][qs+y[i]][i+1] = true;          }        }      }      q.pop();}else if (gn == 2){      for (int i=0;i<4;i++){        if (qf+x[i]>=0 && qs+y[i]>=0 && qf+x[i]<a && qs+y[i]<b){if(smell){            if (!visited[qf+x[i]][qs+y[i]][i+5]){              q.push(make_pair(make_pair(make_pair(qf+x[i],qs+y[i]),make_pair(point+1,1)),make_pair(x[i],y[i])));              visited[qf+x[i]][qs+y[i]][i+5] = true;            }          }else if(!visited[qf+x[i]][qs+y[i]][i+1]){            q.push(make_pair(make_pair(make_pair(qf+x[i],qs+y[i]),make_pair(point+1,1)),make_pair(x[i],y[i])));            visited[qf+x[i]][qs+y[i]][i+1] = true;          }        }      }      q.pop();    }else if (gn == 3){      if (smell){        for (int i=0;i<4;i++){          if (qf+x[i]>=0 && qs+y[i]>=0 && qf+x[i]<a && qs+y[i]<b){if (!visited[qf+x[i]][qs+y[i]][i+5]){              q.push(make_pair(make_pair(make_pair(qf+x[i],qs+y[i]),make_pair(point+1,smell)),make_pair(x[i],y[i])));              visited[qf+x[i]][qs+y[i]][i+5] = true;            }}        }        q.pop();}else{  q.pop();}}else if (gn == 4){      q.pop();      if (qf+df>=0 && qs+ds>=0 && qf+df<a && qs+ds<b){int zz;for (int i=0;i<4;i++) if (df == x[i] && ds == y[i]) zz = i;if (graph[qf+df][qs+ds]!=3 && graph[qf+df][qs+ds]!=0){  if(smell){    if (!visited[qf+df][qs+ds][zz+5]){      q.push(make_pair(make_pair(make_pair(qf+df,qs+ds),make_pair(point+1,0)),make_pair(df,ds)));visited[qf+df][qs+ds][zz+5] = true;    }  }else if(!visited[qf+df][qs+ds][zz+1]){q.push(make_pair(make_pair(make_pair(qf+df,qs+ds),make_pair(point+1,0)),make_pair(df,ds)));    visited[qf+df][qs+ds][zz+1] = true;  }}else{  for (int i=0;i<4;i++){    if (x[i]!=df && y[i]!=ds){      if (qf+x[i]>=0 && qs+y[i]>=0 && qf+x[i]<a && qs+y[i]<b){if (graph[qf+x[i]][qs+y[i]]!=3 && graph[qf+x[i]][qs+y[i]]!=0){if(smell){if (!visited[qf+x[i]][qs+y[i]][i+5]){    q.push(make_pair(make_pair(make_pair(qf+x[i],qs+y[i]),make_pair(point+1,0)),make_pair(x[i],y[i])));    visited[qf+x[i]][qs+y[i]][i+5] = true;  }}else if(!visited[qf+x[i]][qs+y[i]][i+1]){  q.push(make_pair(make_pair(make_pair(qf+x[i],qs+y[i]),make_pair(point+1,0)),make_pair(x[i],y[i])));  visited[qf+x[i]][qs+y[i]][i+1] = true;}}}}}}}else{        for (int i=0;i<4;i++){if (x[i]!=df && y[i]!=ds){if (qf+x[i]>=0 && qs+y[i]>=0 && qf+x[i]<a && qs+y[i]<b){if (graph[qf+x[i]][qs+y[i]]!=3 && graph[qf+x[i]][qs+y[i]]!=0){if(smell){if (!visited[qf+x[i]][qs+y[i]][i+5]){q.push(make_pair(make_pair(make_pair(qf+x[i],qs+y[i]),make_pair(point+1,0)),make_pair(x[i],y[i])));visited[qf+x[i]][qs+y[i]][i+5] = true;}else if(!visited[qf+x[i]][qs+y[i]][i+1]){q.push(make_pair(make_pair(make_pair(qf+x[i],qs+y[i]),make_pair(point+1,0)),make_pair(x[i],y[i])));visited[qf+x[i]][qs+y[i]][i+1] = true;}}}}}      }    }  }  if (mini == 200000000){    cout << -1;  }else{    cout << mini;  }}
